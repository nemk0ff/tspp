/**
 * @file ExpressionParser.h
 * @author Kostenko Alisa
 * @brief Заголовочный файл, описывающий калькулятор математических выражений, которые разбираются на операнды методом
 * рекурсивного спуска
 * @date 07.06.2024
 */

#pragma once

#include <stack>
#include <string>
#include "math.h"

//! Выполняется парсинг математических выражений методом рекурсивного спукса в
//! формат, аналогичный польской инверсной нотации, далее инструкциями внутри
//! рекурсивного спуска этот ПолИЗ вычисляется и сохраняет значение выражения на стеке.
//! \brief Класс парсера математических выражений
class ExpressionParser {
    //! \brief Индекс анализируемого символа
    size_t cur_index;
    //! \brief Математическое выражение
    std::string s;
    //! \brief Стек, хранящий операнды
    std::stack<value_t> values;

    //! \brief Функция РС, выполняющая парсинг операндов между операциями + и -
    //! \param unary_minus Если ранее был встречен унарный минус, то его нужно применить к первому операнду
    void S(bool unary_minus = false);
    //! \brief Функция РС, выполняющая парсинг операндов между операциями * и /
    void M();
    //! \brief Функция РС, выполняющая парсинг операндов между операцией ^
    void P();
    //! \brief Функция РС, выполняющая парсинг операндов-значений - значений функций, чисел или подвыражений в скобочках
    void V();
    //! \brief Функция РС, выполняющая парсинг чисел
    void D();

public:
    //! \brief Функция парсера, производящая парсинг и вычисление выражения
    //! \param s_ Математическое выражение
    long double parse(const std::string& s_);
};
